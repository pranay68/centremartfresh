import React, { useState, useEffect, useRef, useCallback } from 'react';
import { collection, getDocs, addDoc, updateDoc, deleteDoc, doc, onSnapshot, query, orderBy, getDoc, limit, startAfter, where } from 'firebase/firestore';
import { db } from '../../firebase/config';
import Card from '../../components/ui/Card';
import Button from '../../components/ui/Button';
import Input from '../../components/ui/Input';
import BulkProductUpload from '../components/BulkProductUpload';
import { toast } from 'react-hot-toast';
import './AdminProductPanel.css';
import { Link } from 'react-router-dom';
import Modal from '../../components/ui/Modal';
import { FaSearch } from 'react-icons/fa';
import { uploadToCloudinary } from '../../utils/cloudinaryUpload';
import { searchProducts } from '../../utils/productSearch';
import { sortByStock } from '../../utils/sortProducts';
import throttle from 'lodash/throttle';

const Products = () => {
  // State for products and filtering
  const [products, setProducts] = useState([]);
  const [filteredProducts, setFilteredProducts] = useState([]);
  const [visibleProducts, setVisibleProducts] = useState(10); // Show initial 10 products
  const [lastDoc, setLastDoc] = useState(null);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('All Products');
  const [categoriesList, setCategoriesList] = useState([]);
  const productListRef = useRef(null);

  // Fetch initial batch of products
  useEffect(() => {
    const fetchInitialProducts = async () => {
      const productsRef = collection(db, 'products');
      const q = query(productsRef, orderBy('name'), limit(10));
      
      const snapshot = await getDocs(q);
      const productsData = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        stock: doc.data().stock || 0,
      }));

      setProducts(productsData);
      setFilteredProducts(productsData);
      setLastDoc(snapshot.docs[snapshot.docs.length - 1]);
      setLoading(false);
    };

    fetchInitialProducts();
  }, []);

  // Fetch more products when scrolling
  const fetchMoreProducts = useCallback(async () => {
    if (!hasMore || loading || !lastDoc) return;
    
    setLoading(true);
    const productsRef = collection(db, 'products');
    let q = query(
      productsRef, 
      orderBy('name'),
      startAfter(lastDoc),
      limit(5)
    );

    // Add category filter if selected
    if (selectedCategory !== 'All Products') {
      q = query(q, where('category', '==', selectedCategory));
    }

    // Add out-of-stock filter if viewing out-of-stock products
    if (selectedCategory === 'Out of Stock') {
      q = query(q, where('stock', '==', 0));
    }

    try {
      const snapshot = await getDocs(q);
      const newProducts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        stock: doc.data().stock || 0,
      }));

      setProducts(prev => [...prev, ...newProducts]);
      setFilteredProducts(prev => [...prev, ...newProducts]);
      setLastDoc(snapshot.docs[snapshot.docs.length - 1]);
      setHasMore(newProducts.length === 5);
    } catch (error) {
      console.error('Error fetching more products:', error);
      toast.error('Failed to load more products');
    } finally {
      setLoading(false);
    }
  }, [hasMore, loading, lastDoc, selectedCategory]);

  // Set up intersection observer for infinite scroll
  useEffect(() => {
    const observer = new IntersectionObserver(
      entries => {
        if (entries[0].isIntersecting && hasMore && !loading) {
          fetchMoreProducts();
        }
      },
      { rootMargin: '100px' }
    );

    if (productListRef.current) {
      observer.observe(productListRef.current);
    }

    return () => observer.disconnect();
  }, [hasMore, loading, fetchMoreProducts]);

  // Search and filter products
  const handleSearch = useCallback(
    throttle(async (term) => {
      setSearchTerm(term);
      if (!term) {
        setFilteredProducts(products.slice(0, visibleProducts));
        return;
      }

      try {
        const searchResults = await searchProducts(term, products);
        setFilteredProducts(searchResults.slice(0, visibleProducts));
      } catch (error) {
        console.error('Search error:', error);
        toast.error('Search failed');
      }
    }, 300),
    [products, visibleProducts]
  );

  // Update visible products when scrolling
  const onScroll = useCallback(() => {
    if (!productListRef.current) return;
    
    const { scrollTop, scrollHeight, clientHeight } = productListRef.current;
    if (scrollTop + clientHeight >= scrollHeight - 100) {
      setVisibleProducts(prev => prev + 5);
    }
  }, []);

  // Add scroll listener
  useEffect(() => {
    const listElement = productListRef.current;
    if (listElement) {
      listElement.addEventListener('scroll', onScroll);
      return () => listElement.removeEventListener('scroll', onScroll);
    }
  }, [onScroll]);

  return (
    <div className="admin-products-container">
      <div className="admin-header">
        <h1>Products Management</h1>
        <div className="search-bar">
          <FaSearch className="search-icon" />
          <Input
            type="text"
            placeholder="Search products..."
            value={searchTerm}
            onChange={(e) => handleSearch(e.target.value)}
          />
        </div>
      </div>

      <div className="product-filters">
        <Button 
          onClick={() => setSelectedCategory('All Products')}
          variant={selectedCategory === 'All Products' ? 'primary' : 'outline'}
        >
          All Products
        </Button>
        <Button 
          onClick={() => setSelectedCategory('Out of Stock')}
          variant={selectedCategory === 'Out of Stock' ? 'primary' : 'outline'}
        >
          Out of Stock
        </Button>
        {/* Add more filter buttons as needed */}
      </div>

      <div className="product-list" ref={productListRef}>
        {filteredProducts.map((product, index) => (
          <div 
            key={product.id}
            className="product-item"
            ref={index === filteredProducts.length - 1 ? productListRef : null}
          >
            {/* Product card content */}
            <div className="product-card">
              <img src={product.imageUrl || 'placeholder.jpg'} alt={product.name} />
              <div className="product-info">
                <h3>{product.name}</h3>
                <p>Stock: {product.stock}</p>
                <p>Price: Rs. {product.price}</p>
              </div>
              <div className="product-actions">
                <Button onClick={() => handleEditProduct(product)}>Edit</Button>
                <Button variant="danger" onClick={() => handleDeleteProduct(product.id)}>Delete</Button>
              </div>
            </div>
          </div>
        ))}
        
        {loading && (
          <div className="loading-spinner">
            <div className="spinner"></div>
            <p>Loading more products...</p>
          </div>
        )}
        
        {!loading && filteredProducts.length === 0 && (
          <div className="no-products">
            <p>No products found</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Products;
